### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AppConfig {
  configName: String
  configValue: String
  createdAt: Date
  description: String
  id: Int
  updatedAt: Date
}

input AppConfigInput {
  configName: String!
  configValue: String!
  description: String
}

type AppliedPromotion {
  promotionCode: AppliedPromotionCode
  selectedPackage: Package
}

type AppliedPromotionCode {
  code: String!
  country: String
  courseId: Int
  createdAt: DateTime
  discountType: DiscountType
  id: ID!
  isActive: Boolean!
  period: Int
  price: Int
  sessionTime: Int
  sessionsPerWeek: Int
  updatedAt: DateTime
  value: Int!
}

input AttachStudentInput {
  firstName: String!
  lastName: String!
  userId: ID!
}

input AttachTrialStudentInput {
  languageLevelId: Int!
  lessonBooking: TrialLessonsBookingInput!
  lessonTopicId: Int!
  packageId: Int!
  user: AttachStudentInput!
}

type AuthStudent {
  about: String
  avatar: File
  avatarId: ID
  birthday: Date
  firstName: String
  gender: GenderType
  id: ID!
  isActive: Boolean
  isTrial: Boolean
  langLevel: String
  languageLevel: LanguageLevel
  lastName: String
  lessons: Lesson
  level: Int
  newToken: String
  parentName: String
  pronouns: String
  trialStartAt: DateTime
  user: User
}

type AuthenticatedUser {
  acceptingStudents: Boolean
  address: String
  avatar: File
  avatarId: ID
  cardLast4: String
  country: String
  email: String!
  firstName: String!
  gender: GenderType
  googleAuth: GoogleAuthObject
  googleCalendarSync: Boolean
  id: ID!
  isActive: Boolean
  koreanEquivalent: String
  lastName: String!
  mentor: Mentor
  newToken: String
  paymentCurrency: Currency
  personalPromotionCodes: [PromotionCode]
  phoneNumber: String
  role: UserRoleType
  students: [AuthStudent]
  timeZone: String!
}

type AvailabilitySlot {
  date: String!
  from: String!
  to: String!
}

type AvailableMentorsFilterSlot {
  day: String
  from: String
  to: String
}

type AvailableMentorsResult {
  filterSlot: AvailableMentorsFilterSlot
  mentors: [Mentor]
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

type CombinedTimesheet {
  day: String
  from: String
  id: ID!
  mentor: Mentor
  mentors: [Int]
  reserved: Boolean
  to: String
}

type Conversation {
  conversationType: ConversationType
  createdAt: DateTime!
  description: String
  id: ID!
  messages: [Message]!
  participants: [User]!
  updatedAt: DateTime!
}

input ConversationInput {
  conversationType: ConversationType!
  participants: [ID!]!
}

enum ConversationType {
  private
  public
}

type Course {
  active: Boolean
  description: String
  id: ID!
  isTrial: Boolean
  languageLevels: [LanguageLevel]
  packages: [Package]
  sequence: Int
  title: String
  translations: [CourseTranslation]
}

input CourseInput {
  active: Boolean
  description: String!
  isTrial: Boolean
  languageLevelIds: [Int!]
  sequence: Int
  title: String!
  translations: [CourseTranslationInput!]!
}

type CourseTranslation {
  course: Course
  description: String
  id: ID!
  language: CourseTranslationsLanguage
  title: String
}

input CourseTranslationInput {
  description: String!
  id: ID
  language: CourseTranslationsLanguage! = kr
  title: String!
}

enum CourseTranslationsLanguage {
  cn
  en
  kr
}

enum Currency {
  krw
  twd
  usd
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type DeleteResult {
  id: Int
}

enum DiscountType {
  fixed
  percent
}

type ExceptionDate {
  date: String
  from: String
  id: ID!
  mentor: Mentor
  to: String
}

input ExceptionDateEntryResponse {
  date: String!
  slots: [TimesheetSlot!]!
}

input ExceptionDateInput {
  exceptionDates: [ExceptionDateEntryResponse!]!
  mentorId: ID!
}

type File {
  createdAt: DateTime
  height: Int
  id: ID!
  mimetype: String
  name: String
  path: String
  updatedAt: DateTime
  url: String
  width: Int
}

type FlatJoinedPaymentOjbect {
  adminNote: String
  buyPrice: Int
  cancelReason: String
  completeLessonCount: Int
  createdAt: DateTime
  currency: String
  id: Int
  metadata: JSON
  originalPrice: Int
  otherLessonCount: Int
  packageCourseTitle: String
  packageDiscountValue: String
  packagePackageSubscriptionCredits: Int
  packagePackageSubscriptionId: Int
  packagePackageSubscriptionModifyCredits: String
  packagePeriod: Int
  packagePrice: Int
  packageSessionTime: Int
  packageSessionsPerWeek: Int
  packageTotalSessions: Int
  promotionCodeDiscountValue: String
  provider: PaymentProviderType
  scheduleLessonCount: Int
  status: PaymentStatusType
  studentFirstName: String
  studentLastName: String
  totalRemaining: Int
  updatedAt: DateTime
  userEmail: String
  userPhoneNumber: String
}

enum GenderType {
  female
  male
  nonbinary
}

enum GeneralTrialFilterType {
  all
  only_regular
  only_trial
}

type GoogleAuthObject {
  refreshTokenDaysRemaining: Int
  url: String
}

type GoogleCalendarResponse {
  calendarId: String
  id: Int
  userGoogleCalendars: JSON
}

type Homework {
  description: String
  id: ID!
  title: String
  topics: [Topic]
}

type InvitedStudent {
  email: String
  firstName: String
  giftForFriend: PromotionCode
  id: ID!
  lastName: String
  purchaseAmount: Int
  trialDate: Date
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type LanguageLevel {
  courses: [Course]
  createdAt: DateTime
  description: String
  id: ID
  isActive: Boolean
  sortOrder: Int
  title: String
  topics: [Topic]
  translations: [LanguageLevelTranslation]
  updatedAt: DateTime
}

input LanguageLevelInput {
  coursesIds: [Int]
  description: String
  id: Int
  isActive: Boolean
  sortOrder: Int
  title: String!
  topicsIds: [Int]
  translations: [LanguageLevelTranslationInput!]!
}

type LanguageLevelTranslation {
  description: String
  id: ID!
  language: CourseTranslationsLanguage
  languageLevel: LanguageLevel
  title: String
}

input LanguageLevelTranslationInput {
  description: String!
  id: ID
  language: CourseTranslationsLanguage! = kr
  title: String!
}

type LanguageLevelWithPagination {
  count: Int!
  languageLevels: [LanguageLevel]!
}

enum LanguageSkillType {
  basic
  excellent
  fair
  good
  great
  insufficient
}

type Lesson {
  cancelAction: LessonCancelActionType
  cancelReason: String
  canceledAt: DateTime
  canceledBy: UserRoleType
  duration: Int
  goal: String
  id: ID!
  isTrial: Boolean
  langLevel: String
  languageLevel: LanguageLevel
  mentor: Mentor
  mentorReview: MentorReview
  packageSubscription: PackageSubscription
  playground: Playground
  preTrialNote: String
  startAt: DateTime
  status: LessonStatusType
  student: Student
  studentReview: StudentReview
  topic: Topic
}

enum LessonCancelActionType {
  assign_new_mentor
  refund
}

type LessonSection {
  completed: Boolean
  description: String
  id: ID!
  title: String
  topics: [Topic]
}

enum LessonStatusType {
  approved
  canceled
  completed
  in_progress
  paid
  rescheduled
  scheduled
}

type LessonsWithPagination {
  count: Int!
  lessons: [Lesson]!
}

type Mentor {
  about: String
  acceptingStudents: Boolean
  availabilities: [Timesheet]!
  avatar: File
  avatarId: ID
  degree: String
  exceptionDates: [ExceptionDate]!
  experience: String
  facts: String
  firstName: String
  fullName: String
  gender: GenderType
  graduatingYear: Int
  hourlyRate: Int
  id: ID!
  introduction: String
  isActive: Boolean
  language: String
  lastName: String
  lessons: Lesson
  major: String
  mentorAvailability: MentorAvailabilityType
  playgroundId: String
  relevantExperience: String
  sortOrder: Int
  uniqueFacts: String
  university: String
  user: User
  userId: ID
  videoUrl: String
  visibilityStatus: VisibilityStatus
}

enum MentorAvailabilityType {
  only_regular
  only_trial
  regular_and_trial
}

type MentorReview {
  confidence: LanguageSkillType
  expressions: LanguageSkillType
  fluency: LanguageSkillType
  homeworks: [Homework]
  id: ID!
  improvement: String
  lesson: Lesson
  listening: LanguageSkillType
  mastered: String
  mentor: Mentor
  pronunciation: LanguageSkillType
  rating: Int
  reading: LanguageSkillType
  student: Student
  vocabularies: [Vocabulary]
  vocabulary: LanguageSkillType
}

input MentorReviewInput {
  confidence: LanguageSkillType!
  expressions: LanguageSkillType!
  fluency: LanguageSkillType!
  homeworkIds: [ID!]!
  improvement: String!
  lessonId: ID!
  lessonSectionId: ID
  listening: LanguageSkillType!
  mastered: String!
  mentorId: ID!
  pronunciation: LanguageSkillType!
  rating: Int!
  reading: LanguageSkillType!
  topicId: ID!
  vocabulary: LanguageSkillType!
  vocabularyIds: [ID!]!
}

type MentorReviewsWithPagination {
  count: Int!
  mentorReviews: [MentorReview]!
}

enum MentorTrialFilterType {
  all
  only_regular
  only_trial
  regular_and_trial
}

input MentorUpdateInput {
  about: String
  avatar: Upload
  degree: String
  experience: String
  facts: String
  firstName: String
  gender: GenderType
  graduatingYear: Int
  hourlyRate: Int
  introduction: String
  isActive: Boolean
  language: String
  lastName: String
  major: String
  mentorAvailability: MentorAvailabilityType
  pronouns: String
  relevantExperience: String
  role: String
  uniqueFacts: String
  university: String
  videoUrl: String
  visibilityStatus: VisibilityStatus
}

type Message {
  body: String
  createdAt: DateTime!
  id: ID!
  meta: JSON
  recipients: [MessageRecipient]
  sender: User
  updatedAt: DateTime!
}

input MessageInput {
  body: String!
  conversationId: ID
  meta: JSON
}

type MessageRecipient {
  id: ID!
  message: Message!
  readAt: DateTime
  recipient: User!
}

input MessageSubscribeInput {
  conversationId: ID
}

type Mutation {
  acceptNewStudents(accept: Boolean!, mentorId: ID!): Boolean!
  applyPromotionCodeForPackage(code: String!, currency: Currency, packageId: ID!): AppliedPromotion!
  approveLesson(id: ID!, mentorId: ID!): Lesson!
  attachPlaygroundToMentorResolver(firstName: String!, lastName: String!, mentorId: ID!): Mentor!
  attachStudentToUser(firstName: String!, lastName: String!, userId: ID!): Student!
  attachTrialStudentToUserResolver(data: AttachTrialStudentInput!): Student!
  cancelLessons(cancelReason: String, id: ID!, isTrial: Boolean = false, repeat: Boolean = false): [Lesson]!
  changeStudentLanguageLevel(languageLevelId: Int!, studentId: ID!): Student!
  createConversation(data: ConversationInput!): Conversation
  createCourse(data: CourseInput!): Course!
  createExceptionDates(data: ExceptionDateInput!): [ExceptionDate]!
  createHomework(description: String, title: String!, topicIds: [ID!]!): Homework!
  createLessonSection(description: String, title: String!, topicIds: [ID!]!): LessonSection!
  createLessons(duration: Int!, mentorId: ID!, packageSubscriptionId: ID!, repeat: Int, startAt: DateTime!, studentId: ID!): [Lesson]!
  createMentor(data: MentorUpdateInput!, user: SignUpInput!): Mentor!
  createMentorReview(data: MentorReviewInput!): MentorReview!
  createPackage(data: PackageCreationInput!): Package!
  createPayment(metadata: String, packageId: ID!, provider: PaymentProviderType, studentId: ID!): Payment!
  createPaymentIntent(applyPersonalDiscountCode: Boolean, currency: Currency, packageId: Int!): StripeResult!
  createPayout(data: PayoutsInput!, isTrial: Boolean): Payout!
  createPlaygroundLink(lessonId: ID!, mentorId: ID!): Lesson!
  createPromotionCode(data: PromotionCodeInput!): PromotionCode!
  createStudent(about: String, langLevel: String, languageLevelId: ID, parentName: String, userId: Int!): Student!
  createStudentReview(lessonId: ID!, rating: Int!, studentId: ID!, tags: [ID!]): StudentReview!
  createStudentReviewTag(title: String!, translations: [StudentReviewTagTranslationInput!], type: StudentReviewTagType!): StudentReviewTag!
  createUser(data: UserCreateInput!): User!
  createVocabularyWord(topicIds: [ID!]!, word: String!): Vocabulary!
  deactivateCourse(id: Int!): Course!
  deactivateStudent(id: ID!): Student!
  deleteConversation(id: ID!): Conversation
  deleteHomework(homeworkId: ID!): Homework!
  deleteLessonSection(lessonSectionId: ID!): LessonSection!
  deletePackage(id: ID!): DeleteResult!
  deletePayment(id: Int!): DeleteResult!
  deleteRecording(id: ID!): Playground!
  deleteStudentReviewTag(id: ID!): StudentReviewTag!
  deleteVocabularyWord(vocabularyId: ID!): Vocabulary!
  generateReferralLink(studentId: ID!): ReferralCode!
  markMessageAsRead(id: [ID!]!): [Message]
  persistLanguageLevel(data: LanguageLevelInput!): LanguageLevel!
  persistTopic(data: TopicInput!): Topic!
  redeemUserPasswordResetToken(password: String!, token: String!): Boolean!
  removeParticipantFromConversationResolver(conversationId: Int!, participantIds: [Int!]!): Conversation
  rescheduleLessons(id: ID!, mentorId: ID!, repeat: Boolean = false, startAt: DateTime!): [Lesson]!
  savedefaultgooglecalendar(calendarId: String!, id: ID!): GoogleCalendarResponse
  sendMessage(data: MessageInput!): Message
  sendSystemMessage(data: MessageInput!): Message
  sendUserPasswordResetLink(email: String!, locale: String!): Boolean!
  setLessonDetails(goal: String, lessonId: ID!, preTrialNote: String, recordingUrl: String, studentId: ID!): Lesson!
  signIn(email: String!, password: String!): SignInResult!
  signUp(data: SignUpInput!): User!
  sortMentors(mentorIds: [Int!]!, startOrderIndex: Int): [Mentor]
  trialSignUp(data: TrialSignUpInput!): User!
  updateCourse(data: CourseInput, id: ID!): Course!
  updateExceptionDates(data: [UpdateExceptionDateInput!], mentorId: ID!): [ExceptionDate]!
  updateHomework(description: String, homeworkId: ID!, title: String, topicIds: [ID!]): Homework!
  updateLessonSection(description: String, lessonSectionId: ID!, title: String, topicIds: [ID!]): LessonSection!
  updateMentor(data: MentorUpdateInput!, id: ID!): Mentor!
  updatePackage(data: PackageUpdateInput!): Package!
  updatePackageSubscription(data: PackageSubscriptionInput!, id: ID!): PackageSubscription!
  updatePayment(adminNote: String, cancelReason: String, id: Int!, status: PaymentStatusType): Payment!
  updatePromotionCode(data: PromotionCodeInput!, id: ID!): PromotionCode!
  updateStudent(data: StudentUpdateInput!, id: ID!): Student!
  updateStudentReviewTag(id: ID!, title: String!, translations: [StudentReviewTagTranslationInput!], type: StudentReviewTagType!): StudentReviewTag!
  updateTimesheets(data: [UpdateTimesheetSlotInput!], mentorId: ID!): [Timesheet]!
  updateUser(data: UserUpdateInput!, id: ID!): User!
  updateVocabularyWord(topicIds: [ID!], vocabularyId: ID!, word: String): Vocabulary!
  upsertExceptionDates(data: ExceptionDateInput!): [ExceptionDate]!
  upsertTimesheets(mentorId: ID!, timesheets: [TimesheetSlot!]!, timezone: String): [Timesheet]!
  upsertTrialLessonSlotLimit(data: [TrialLessonSlotLimitInput!]): [TrialLessonSlotLimit]!
}

type Package {
  course: Course
  courseId: ID
  discount: Int
  discountPrice: Int
  id: ID!
  isReferral: Boolean
  packageSubscription: [PackageSubscription]
  period: Int
  prices: [PackageCurrencyPrice]
  promotionCode: PromotionCode
  referralDiscount: Int
  sessionTime: Int
  sessionsPerWeek: Int
  student: Student
  totalSessions: Int
}

input PackageCreationInput {
  courseId: Int!
  discount: Int
  period: Int
  prices: [PackageCurrencyPriceCreationInput!]!
  sessionTime: Int!
  sessionsPerWeek: Int!
  totalSessions: Int!
}

type PackageCurrencyPrice {
  currency: Currency!
  id: Int
  packageId: Int!
  price: Int!
}

input PackageCurrencyPriceCreationInput {
  currency: Currency!
  price: Int!
}

input PackageCurrencyPriceUpdateInput {
  currency: Currency!
  id: Int!
  price: Int!
}

type PackageSubscription {
  active: Boolean
  credits: Int
  id: ID!
  lessons: [Lesson]
  modifyCredits: Int
  package: Package
  packageId: ID!
  payment: Payment
  paymentId: ID
  periodEnd: DateTime
  periodStart: DateTime
  promotionCodeStudentUsage: [PromotionCodeUsageInverseSide]
  student: Student
}

input PackageSubscriptionInput {
  credits: Int
  modifyCredits: Int
  packageId: ID
  periodEnd: String
  periodStart: String
}

type PackageSubscriptionPromotionCode {
  active: Boolean
  credits: Int
  id: ID!
  lessons: [Lesson]
  modifyCredits: Int
  package: Package
  packageId: ID!
  payment: Payment
  paymentId: ID!
  periodEnd: DateTime
  periodStart: DateTime
  promotionCodeStudentUsage: [PromotionCodeUsageInverseSide]
  student: Student
}

input PackageUpdateInput {
  courseId: Int
  discount: Int
  id: Int!
  period: Int
  prices: [PackageCurrencyPriceUpdateInput!]
  sessionTime: Int
  sessionsPerWeek: Int
  totalSessions: Int
}

type Payment {
  adminNote: String
  buyPrice: Int
  cancelReason: String
  createdAt: DateTime
  currency: String
  id: Int
  metadata: JSON
  originalPrice: Int
  package: Package
  packageDiscount: Int
  packageDiscountValue: Int
  packageSubscription: PackageSubscription
  promotionCodeDiscountValue: Int
  provider: PaymentProviderType
  status: PaymentStatusType
  updatedAt: DateTime
  user: User
}

enum PaymentProviderType {
  migrated
  stripe
}

type PaymentResult {
  payment: Payment
}

enum PaymentStatusType {
  canceled
  failed
  paid
  pending
  refunded
  scheduled
}

type PaymentsWithPagination {
  count: Int!
  payments: [FlatJoinedPaymentOjbect]!
}

type Payout {
  amount: Float
  billingFrom: DateTime
  billingTo: DateTime
  canceledLessonsCount: Int
  completedLessonsCount: Int
  id: ID
  isTrial: Boolean
  lessonIds: [Int]
  lessonsCount: Int
  mentor: Mentor
  minutesTaught: Float
}

input PayoutsInput {
  amount: Float!
  billingFrom: DateTime!
  billingTo: DateTime!
  canceledLessonsCount: Int!
  completedLessonsCount: Int!
  lessonIds: [Int!]!
  lessonsCount: Int!
  mentorId: ID!
  minutesTaught: Float!
}

type Playground {
  id: ID!
  joinUrl: String
  meetingId: String
  recordingReady: Boolean
  recordingUrl: String
  startUrl: String
}

type PromotionCode {
  code: String!
  country: String
  courseId: Int
  createdAt: DateTime
  discountType: DiscountType
  id: ID!
  isActive: Boolean!
  period: Int
  promotionCodeStudentUsage: [PromotionCodeUsage]
  sessionTime: Int
  sessionsPerWeek: Int
  totalPromotionCodeDiscount: Int
  updatedAt: DateTime
  value: Int!
}

input PromotionCodeInput {
  code: String!
  country: String
  courseId: Int
  discountType: DiscountType = percent
  isActive: Boolean!
  period: Int
  sessionTime: Int
  sessionsPerWeek: Int
  value: Int!
}

type PromotionCodePackage {
  packageId: Int!
  promotionCodeId: Int!
}

type PromotionCodeUsage {
  packageSubscription: PackageSubscriptionPromotionCode
}

type PromotionCodeUsageInverseSide {
  promotionCode: PromotionCode
  usedAt: Date
}

type Query {
  activePackageSubscriptions(studentId: ID!): [PackageSubscription]!
  appConfig(id: Int!): AppConfig
  appConfigs: [AppConfig!]
  authenticatedUser(studentId: ID): AuthenticatedUser
  availabilitySlots(duration: Int!, mentorId: ID!, rangeEnd: String!, rangeStart: String!, timezone: String!): [AvailabilitySlot]!
  availableMentors(duration: Int!, studentId: String!, time: String!): AvailableMentorsResult!
  availableMentorsFroTrial(duration: Int!, time: String!): AvailableMentorsResult!
  checkStripePaymentStatus(paymentIntentId: String!): Boolean!
  combinedTimesheets(date: String!, duration: String!, mentorId: ID, studentId: ID, trial: Boolean, tz: String!): [CombinedTimesheet]!
  combinedTimesheetsForTrials(date: String!, mentorId: ID, tz: String!): [CombinedTimesheet]!
  conversation(id: ID!): Conversation!
  conversations: [Conversation]!
  course(id: Int!): Course!
  courses(applyPersonalDiscountCode: Boolean, studentId: ID, trialFilter: GeneralTrialFilterType = all): [Course]!
  createAppConfig(data: AppConfigInput!): AppConfig
  creditsCount(id: ID!): Int!
  currencies: [Currency]
  getReferralCode(studentId: ID!): ReferralCode!
  getUserNotifications: [Message]!
  googlecalendarresponse: GoogleCalendarResponse
  homework(topicId: ID): [Homework]!
  languageLevel(id: ID!): LanguageLevel!
  languageLevelsWithPagination(limit: Int, page: Int, search: String): LanguageLevelWithPagination!
  lesson(id: ID!): Lesson
  lessonSections(topicId: ID): [LessonSection]!
  lessons(mentorId: ID, status: String, studentId: ID): [Lesson]!
  lessonsWithPagination(limit: Int, order: RowsOrdering, page: Int, search: String, startAtFrom: DateTime, startAtTo: DateTime, status: String, trialFilter: GeneralTrialFilterType = all): LessonsWithPagination!
  mentor(id: ID!): Mentor
  mentorReviewsWithPagination(limit: Int, order: RowsOrdering, page: Int, search: String): MentorReviewsWithPagination!
  mentors(studentId: ID, visibilityStatus: VisibilityStatus): [Mentor]!
  mentorsWithPagination(limit: Int, order: RowsOrdering, orderBy: String, page: Int, search: String, trialFilter: MentorTrialFilterType = all): mentorsWithPagination
  package(id: Int!): Package
  packageSubscription(id: ID!): PackageSubscription
  packageSubscriptions(userId: ID!): [PackageSubscription]
  packagesWithPagination(course: Int, limit: Int, month: Int, order: RowsOrdering, page: Int, sessionTime: Int, sessionsPerWeek: Int, trialFilter: GeneralTrialFilterType = all): packagesWithPagination!
  payment(id: Int!): Payment!
  paymentsWithPagination(limit: Int, order: RowsOrdering, orderBy: String, page: Int, renewal: String, search: String, status: String): PaymentsWithPagination!
  payoutsHistoryWithPagination(limit: Int, order: RowsOrdering, page: Int): payoutsHistoryWithPagination
  payoutsWithPagination(endDate: String!, limit: Int, order: RowsOrdering, page: Int, search: String, startDate: String!, trialFilter: GeneralTrialFilterType = all): payoutsWithPagination
  playgroundLesson(playgroundId: String!): Lesson
  promotionCode(id: ID!): PromotionCode
  promotionCodesWithPagination(limit: Int, order: RowsOrdering, page: Int, search: String): promotionCodesWithPagination!
  publicMentorList: [Mentor]
  student(id: ID!): Student!
  studentReferral(id: ID!): StudentReferral!
  studentReferralWithPagination(limit: Int, order: RowsOrdering, page: Int, search: String): StudentReferralWithPagination!
  studentReviewTagById(id: ID!): StudentReviewTag!
  studentReviewTagsByType(type: StudentReviewTagType): [StudentReviewTag]!
  studentReviewsWithPagination(limit: Int, order: RowsOrdering, page: Int, search: String): StudentReviewsWithPagination!
  students: [Student]!
  studentsWithPagination(limit: Int, order: RowsOrdering, page: Int, search: String, trialFilter: StudentTrialFilterType = all): studentsWithPagination!
  topic(id: ID!): Topic!
  topics: [Topic]!
  topicsWithPagination(limit: Int, page: Int, search: String): TopicWithPagination!
  trialLessonSlotLimitWithPagination(limit: Int, page: Int, search: String): TrialLessonSlotLimitWithPagination
  trialPackages: [TrialPackage]
  updateAppConfig(data: UpdateAppConfigInput!): AppConfig
  users: [User]!
  validateReferralCode(referralCode: String!): ValidationReferralCodeResult!
  vocabulary(topicId: ID): [Vocabulary]!
}

type ReferralCode {
  code: String!
  createdAt: DateTime
  expiredAt: DateTime
  id: ID!
  promoterStudentId: ID!
  referralUrl: String
  updatedAt: DateTime
  usages: [ReferralCodeUsage]
}

enum ReferralCodeStatus {
  first_package_purchased
  regular_sign_up
  trial_lesson_completed
  trial_sign_up
}

type ReferralCodeUsage {
  createdAt: DateTime
  expiredAt: DateTime
  id: ID!
  referralCodeId: ID!
  referralStatus: ReferralCodeStatus
  updatedAt: DateTime
  usages: [ReferralCodeUsage]
}

enum RowsOrdering {
  asc
  desc
}

type SelectReferralBonusLessonResult {
  isSuccess: Boolean
}

type SignInResult {
  sessionToken: String
  user: User
}

input SignUpInput {
  email: String!
  firstName: String!
  isTrial: Boolean
  languageLevelId: Int
  lastName: String!
  password: String!
  phoneNumber: String
  referralCode: String
  timeZone: String
}

type StripeResult {
  clientSecret: String
}

type Student {
  about: String
  activeSubscriptions: [PackageSubscription]
  avatar: File
  avatarId: ID
  birthday: Date
  firstName: String
  gender: GenderType
  id: ID!
  isActive: Boolean
  langLevel: String
  languageLevel: LanguageLevel
  lastName: String
  lessons: Lesson
  level: Int
  parentName: String
  pronouns: String
  user: User
}

type StudentReferral {
  email: String
  firstName: String
  friends: [InvitedStudent]
  giftForStudent: Int
  id: Int!
  lastName: String
  phoneNumber: String
  referralDiscountCodesUsed: Int
  referralsCount: Int
  referralsPackagePurchased: Int
}

type StudentReferralWithPagination {
  count: Int
  studentReferrals: [StudentReferral]!
}

type StudentReview {
  id: ID!
  lesson: Lesson
  mentor: Mentor
  rating: Int
  student: Student
  tags: [StudentReviewTag]
}

type StudentReviewTag {
  id: ID!
  title: String
  translations: [StudentReviewTagTranslation]
  type: StudentReviewTagType
}

type StudentReviewTagTranslation {
  id: ID!
  language: CourseTranslationsLanguage!
  title: String!
}

input StudentReviewTagTranslationInput {
  id: ID
  language: CourseTranslationsLanguage! = kr
  title: String!
}

enum StudentReviewTagType {
  bad
  good
  neutral
}

type StudentReviewsWithPagination {
  count: Int!
  studentReviews: [StudentReview]!
}

enum StudentTrialFilterType {
  all
  only_regular
  only_trial
  trial_active
  trial_inactive
}

input StudentUpdateInput {
  about: String
  avatar: Upload
  birthday: Date
  firstName: String
  gender: GenderType
  isActive: Boolean
  koreanEquivalent: String
  langLevel: String
  languageLevelId: Int
  lastName: String
  level: Int
}

type Subscription {
  newMessages(conversationId: ID): Message
}

type Timesheet {
  day: String
  from: String
  id: ID!
  isTrial: Boolean
  mentor: Mentor
  to: String
}

input TimesheetAvailability {
  day: String!
  slots: [TimesheetSlot!]!
  trialTimesheet: Boolean!
}

input TimesheetInput {
  availabilities: [TimesheetAvailability!]!
  mentorId: ID!
  timeZone: String
}

input TimesheetSlot {
  day: String!
  from: String!
  id: ID
  isTrial: Boolean
  to: String!
}

type Topic {
  createdAt: DateTime
  description: String
  id: ID
  isActive: Boolean
  languageLevels: [LanguageLevel]
  sortOrder: Int
  title: String
  translations: [TopicTranslation]
  updatedAt: DateTime
}

input TopicInput {
  description: String
  id: Int
  isActive: Boolean
  languageLevelIds: [Int]
  sortOrder: Int
  title: String!
  translations: [TopicTranslationInput!]!
}

type TopicTranslation {
  description: String
  id: ID!
  language: CourseTranslationsLanguage
  title: String
  topic: Topic
}

input TopicTranslationInput {
  description: String!
  id: ID
  language: CourseTranslationsLanguage! = kr
  title: String!
}

type TopicWithPagination {
  count: Int!
  topics: [Topic]!
}

type TrialLessonSlotLimit {
  createdAt: DateTime
  id: ID!
  lessonLimit: String
  startAt: String
  timeZones: [String!]
  updatedAt: DateTime
}

input TrialLessonSlotLimitInput {
  id: Int
  lessonLimit: Int!
  startAt: String!
  timeZones: [String!]!
}

type TrialLessonSlotLimitWithPagination {
  count: Int!
  trialLessonSlotLimits: [TrialLessonSlotLimit]
}

input TrialLessonsBookingInput {
  mentorId: ID!
  repeat: Boolean
  startAt: DateTime
}

type TrialPackage {
  course: Course
  courseId: ID
  id: ID!
  period: Int
  sessionTime: Int
  sessionsPerWeek: Int
  totalSessions: Int
}

input TrialSignUpInput {
  languageLevelId: Int!
  lessonBooking: TrialLessonsBookingInput!
  lessonTopicId: Int!
  packageId: Int!
  user: SignUpInput!
}

input UpdateAppConfigInput {
  configName: String!
  configValue: String!
  description: String
  id: Int!
}

input UpdateExceptionDateInput {
  date: String!
  from: String!
  id: ID!
  to: String!
}

input UpdateTimesheetSlotInput {
  day: String!
  from: String!
  id: ID!
  to: String!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  activeSubscriptions: [PackageSubscription]
  address: String
  cardLast4: String
  conversations: [Conversation]
  country: String
  createdAt: DateTime
  email: String
  id: ID!
  isActive: Boolean
  mentor: Mentor
  notifications: [Message]
  packageSubscriptions: [PackageSubscription]
  paymentCurrency: Currency
  phoneNumber: String
  referalCode: String
  referalId: Int
  role: UserRoleType
  students: [Student]
  timeZone: String
  updatedAt: DateTime
}

input UserCreateInput {
  address: String
  country: String
  email: String!
  firstName: String!
  isActive: Boolean
  lastName: String!
  password: String!
  paymentCurrency: Currency
  phoneNumber: String
  role: UserRoleType
  timeZone: String
}

enum UserRoleType {
  admin
  mentor
  student
  user
}

input UserUpdateInput {
  address: String
  convertAvailabilityTime: Boolean
  country: String
  googleCalendarSync: Boolean
  isActive: Boolean
  marketingChannel: String
  password: String
  paymentCurrency: Currency
  phoneNumber: String
  role: UserRoleType
  timeZone: String
}

type ValidationReferralCodeResult {
  isValid: Boolean
  student: Student
}

enum VisibilityStatus {
  private
  public
}

type Vocabulary {
  id: ID!
  topics: [Topic]
  word: String
}

type mentorsWithPagination {
  count: Int
  mentors: [Mentor]!
}

type packagesWithPagination {
  count: Int
  packages: [Package]!
}

type payoutsHistoryWithPagination {
  count: Int
  payouts: [Payout]!
}

type payoutsWithPagination {
  count: Int
  payouts: [Payout]!
}

type promotionCodesWithPagination {
  count: Int
  promotionCodes: [PromotionCode]!
}

type studentsWithPagination {
  count: Int
  students: [Student]!
}